## Контекст

**Контекст** абстракция, позволяющая передавать значения, сигналы отмены и тд в области запроса.

**Контекст** - является альтернативным неявным путём задания контракта функции, метода, структуры, пайпа обработки запроса и тд.

Пакет context.Context:

```golang
    type Context interface {
        Deadline() (deadline time.Time, ok bool) //
        Done() <-chan struct{} //
        Err() error //
        Value(key any) any // 
    }
```

Контексты наследуются друг от друга, тем самым образуя иерархию контекстов при обработке запросов.

```golang 
    type emptyCtx int
    ...
    
    var (
            background = new(emptyCtx)
            todo       = new(emptyCtx)
    )

    func Background() Context {
	    return background
    }

    func TODO() Context {
        return todo
    }
```

```golang 
    type cancelCtx struct {
        Context
    
        mu       sync.Mutex            // protects following fields
        done     atomic.Value          // of chan struct{}, created lazily, closed by first cancel call
        children map[canceler]struct{} // set to nil by the first cancel call
        err      error                 // set to non-nil by the first cancel call
    }
```

При отмене родительского контекста отменяются и дочерние. propogateCancel.

 - Передавайте контекст всегда первым аргументом — это общепринятое соглашение;
 - Передавайте контекст только в функции и методы, не храните в состоянии (внутри структуры). Контексты спроектированы так, чтобы их использовали как одноразовые и неизменяемые объекты. Например, если вы сохраните контекст с таймутом в 15 секунд в поле структуры, а спустя 15 секунд попробуете выполнить операцию с данным контекстом, у вас ничего не получится. Обнулить счётчик таймаута вы тоже не сможете;
 - Используйте context.WithValue только в крайних случаях. В 99,(9)% случаев вы сможете передать данные через аргументы функции;
 - context.Background должен использоваться только как самый верхний родительский контекст, поскольку он является заглушкой и не предоставляет средств контроля;
 - Используйте context.TODO, если пока не уверены, какой контекст нужно использовать;
 - Не забывайте вызывать функцию отмены контекста, т.к. функции, принимающей контекст может потребоваться время на завершение перед выходом;
 - Передавайте только контекст, без функции отмены. Контроль за завершением контекста должен оставаться на вызывающей стороне, иначе логика приложения может стать очень запутанной.


